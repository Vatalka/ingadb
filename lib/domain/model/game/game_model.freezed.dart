// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'game_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ListOfGames {
  int get count => throw _privateConstructorUsedError;
  String get next => throw _privateConstructorUsedError;
  dynamic get previous => throw _privateConstructorUsedError;
  List<Games> get results => throw _privateConstructorUsedError;
  String get seoTitle => throw _privateConstructorUsedError;
  String get seoDescription => throw _privateConstructorUsedError;
  String get seoKeywords => throw _privateConstructorUsedError;
  String get seoH1 => throw _privateConstructorUsedError;
  bool get noIndex => throw _privateConstructorUsedError;
  bool get noFollow => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  Filters get filters => throw _privateConstructorUsedError;
  List<String> get noFollowCollections => throw _privateConstructorUsedError;

  /// Create a copy of ListOfGames
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ListOfGamesCopyWith<ListOfGames> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListOfGamesCopyWith<$Res> {
  factory $ListOfGamesCopyWith(
          ListOfGames value, $Res Function(ListOfGames) then) =
      _$ListOfGamesCopyWithImpl<$Res, ListOfGames>;
  @useResult
  $Res call(
      {int count,
      String next,
      dynamic previous,
      List<Games> results,
      String seoTitle,
      String seoDescription,
      String seoKeywords,
      String seoH1,
      bool noIndex,
      bool noFollow,
      String description,
      Filters filters,
      List<String> noFollowCollections});

  $FiltersCopyWith<$Res> get filters;
}

/// @nodoc
class _$ListOfGamesCopyWithImpl<$Res, $Val extends ListOfGames>
    implements $ListOfGamesCopyWith<$Res> {
  _$ListOfGamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ListOfGames
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? next = null,
    Object? previous = freezed,
    Object? results = null,
    Object? seoTitle = null,
    Object? seoDescription = null,
    Object? seoKeywords = null,
    Object? seoH1 = null,
    Object? noIndex = null,
    Object? noFollow = null,
    Object? description = null,
    Object? filters = null,
    Object? noFollowCollections = null,
  }) {
    return _then(_value.copyWith(
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      next: null == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as String,
      previous: freezed == previous
          ? _value.previous
          : previous // ignore: cast_nullable_to_non_nullable
              as dynamic,
      results: null == results
          ? _value.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Games>,
      seoTitle: null == seoTitle
          ? _value.seoTitle
          : seoTitle // ignore: cast_nullable_to_non_nullable
              as String,
      seoDescription: null == seoDescription
          ? _value.seoDescription
          : seoDescription // ignore: cast_nullable_to_non_nullable
              as String,
      seoKeywords: null == seoKeywords
          ? _value.seoKeywords
          : seoKeywords // ignore: cast_nullable_to_non_nullable
              as String,
      seoH1: null == seoH1
          ? _value.seoH1
          : seoH1 // ignore: cast_nullable_to_non_nullable
              as String,
      noIndex: null == noIndex
          ? _value.noIndex
          : noIndex // ignore: cast_nullable_to_non_nullable
              as bool,
      noFollow: null == noFollow
          ? _value.noFollow
          : noFollow // ignore: cast_nullable_to_non_nullable
              as bool,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      filters: null == filters
          ? _value.filters
          : filters // ignore: cast_nullable_to_non_nullable
              as Filters,
      noFollowCollections: null == noFollowCollections
          ? _value.noFollowCollections
          : noFollowCollections // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }

  /// Create a copy of ListOfGames
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FiltersCopyWith<$Res> get filters {
    return $FiltersCopyWith<$Res>(_value.filters, (value) {
      return _then(_value.copyWith(filters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ListOfGamesImplCopyWith<$Res>
    implements $ListOfGamesCopyWith<$Res> {
  factory _$$ListOfGamesImplCopyWith(
          _$ListOfGamesImpl value, $Res Function(_$ListOfGamesImpl) then) =
      __$$ListOfGamesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int count,
      String next,
      dynamic previous,
      List<Games> results,
      String seoTitle,
      String seoDescription,
      String seoKeywords,
      String seoH1,
      bool noIndex,
      bool noFollow,
      String description,
      Filters filters,
      List<String> noFollowCollections});

  @override
  $FiltersCopyWith<$Res> get filters;
}

/// @nodoc
class __$$ListOfGamesImplCopyWithImpl<$Res>
    extends _$ListOfGamesCopyWithImpl<$Res, _$ListOfGamesImpl>
    implements _$$ListOfGamesImplCopyWith<$Res> {
  __$$ListOfGamesImplCopyWithImpl(
      _$ListOfGamesImpl _value, $Res Function(_$ListOfGamesImpl) _then)
      : super(_value, _then);

  /// Create a copy of ListOfGames
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? next = null,
    Object? previous = freezed,
    Object? results = null,
    Object? seoTitle = null,
    Object? seoDescription = null,
    Object? seoKeywords = null,
    Object? seoH1 = null,
    Object? noIndex = null,
    Object? noFollow = null,
    Object? description = null,
    Object? filters = null,
    Object? noFollowCollections = null,
  }) {
    return _then(_$ListOfGamesImpl(
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      next: null == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as String,
      previous: freezed == previous
          ? _value.previous
          : previous // ignore: cast_nullable_to_non_nullable
              as dynamic,
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Games>,
      seoTitle: null == seoTitle
          ? _value.seoTitle
          : seoTitle // ignore: cast_nullable_to_non_nullable
              as String,
      seoDescription: null == seoDescription
          ? _value.seoDescription
          : seoDescription // ignore: cast_nullable_to_non_nullable
              as String,
      seoKeywords: null == seoKeywords
          ? _value.seoKeywords
          : seoKeywords // ignore: cast_nullable_to_non_nullable
              as String,
      seoH1: null == seoH1
          ? _value.seoH1
          : seoH1 // ignore: cast_nullable_to_non_nullable
              as String,
      noIndex: null == noIndex
          ? _value.noIndex
          : noIndex // ignore: cast_nullable_to_non_nullable
              as bool,
      noFollow: null == noFollow
          ? _value.noFollow
          : noFollow // ignore: cast_nullable_to_non_nullable
              as bool,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      filters: null == filters
          ? _value.filters
          : filters // ignore: cast_nullable_to_non_nullable
              as Filters,
      noFollowCollections: null == noFollowCollections
          ? _value._noFollowCollections
          : noFollowCollections // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$ListOfGamesImpl implements _ListOfGames {
  const _$ListOfGamesImpl(
      {required this.count,
      required this.next,
      required this.previous,
      required final List<Games> results,
      required this.seoTitle,
      required this.seoDescription,
      required this.seoKeywords,
      required this.seoH1,
      required this.noIndex,
      required this.noFollow,
      required this.description,
      required this.filters,
      required final List<String> noFollowCollections})
      : _results = results,
        _noFollowCollections = noFollowCollections;

  @override
  final int count;
  @override
  final String next;
  @override
  final dynamic previous;
  final List<Games> _results;
  @override
  List<Games> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  final String seoTitle;
  @override
  final String seoDescription;
  @override
  final String seoKeywords;
  @override
  final String seoH1;
  @override
  final bool noIndex;
  @override
  final bool noFollow;
  @override
  final String description;
  @override
  final Filters filters;
  final List<String> _noFollowCollections;
  @override
  List<String> get noFollowCollections {
    if (_noFollowCollections is EqualUnmodifiableListView)
      return _noFollowCollections;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_noFollowCollections);
  }

  @override
  String toString() {
    return 'ListOfGames(count: $count, next: $next, previous: $previous, results: $results, seoTitle: $seoTitle, seoDescription: $seoDescription, seoKeywords: $seoKeywords, seoH1: $seoH1, noIndex: $noIndex, noFollow: $noFollow, description: $description, filters: $filters, noFollowCollections: $noFollowCollections)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListOfGamesImpl &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.next, next) || other.next == next) &&
            const DeepCollectionEquality().equals(other.previous, previous) &&
            const DeepCollectionEquality().equals(other._results, _results) &&
            (identical(other.seoTitle, seoTitle) ||
                other.seoTitle == seoTitle) &&
            (identical(other.seoDescription, seoDescription) ||
                other.seoDescription == seoDescription) &&
            (identical(other.seoKeywords, seoKeywords) ||
                other.seoKeywords == seoKeywords) &&
            (identical(other.seoH1, seoH1) || other.seoH1 == seoH1) &&
            (identical(other.noIndex, noIndex) || other.noIndex == noIndex) &&
            (identical(other.noFollow, noFollow) ||
                other.noFollow == noFollow) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.filters, filters) || other.filters == filters) &&
            const DeepCollectionEquality()
                .equals(other._noFollowCollections, _noFollowCollections));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      count,
      next,
      const DeepCollectionEquality().hash(previous),
      const DeepCollectionEquality().hash(_results),
      seoTitle,
      seoDescription,
      seoKeywords,
      seoH1,
      noIndex,
      noFollow,
      description,
      filters,
      const DeepCollectionEquality().hash(_noFollowCollections));

  /// Create a copy of ListOfGames
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ListOfGamesImplCopyWith<_$ListOfGamesImpl> get copyWith =>
      __$$ListOfGamesImplCopyWithImpl<_$ListOfGamesImpl>(this, _$identity);
}

abstract class _ListOfGames implements ListOfGames {
  const factory _ListOfGames(
      {required final int count,
      required final String next,
      required final dynamic previous,
      required final List<Games> results,
      required final String seoTitle,
      required final String seoDescription,
      required final String seoKeywords,
      required final String seoH1,
      required final bool noIndex,
      required final bool noFollow,
      required final String description,
      required final Filters filters,
      required final List<String> noFollowCollections}) = _$ListOfGamesImpl;

  @override
  int get count;
  @override
  String get next;
  @override
  dynamic get previous;
  @override
  List<Games> get results;
  @override
  String get seoTitle;
  @override
  String get seoDescription;
  @override
  String get seoKeywords;
  @override
  String get seoH1;
  @override
  bool get noIndex;
  @override
  bool get noFollow;
  @override
  String get description;
  @override
  Filters get filters;
  @override
  List<String> get noFollowCollections;

  /// Create a copy of ListOfGames
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ListOfGamesImplCopyWith<_$ListOfGamesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Filters {
  List<FiltersYearModel> get years => throw _privateConstructorUsedError;

  /// Create a copy of Filters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FiltersCopyWith<Filters> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FiltersCopyWith<$Res> {
  factory $FiltersCopyWith(Filters value, $Res Function(Filters) then) =
      _$FiltersCopyWithImpl<$Res, Filters>;
  @useResult
  $Res call({List<FiltersYearModel> years});
}

/// @nodoc
class _$FiltersCopyWithImpl<$Res, $Val extends Filters>
    implements $FiltersCopyWith<$Res> {
  _$FiltersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Filters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? years = null,
  }) {
    return _then(_value.copyWith(
      years: null == years
          ? _value.years
          : years // ignore: cast_nullable_to_non_nullable
              as List<FiltersYearModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FiltersImplCopyWith<$Res> implements $FiltersCopyWith<$Res> {
  factory _$$FiltersImplCopyWith(
          _$FiltersImpl value, $Res Function(_$FiltersImpl) then) =
      __$$FiltersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<FiltersYearModel> years});
}

/// @nodoc
class __$$FiltersImplCopyWithImpl<$Res>
    extends _$FiltersCopyWithImpl<$Res, _$FiltersImpl>
    implements _$$FiltersImplCopyWith<$Res> {
  __$$FiltersImplCopyWithImpl(
      _$FiltersImpl _value, $Res Function(_$FiltersImpl) _then)
      : super(_value, _then);

  /// Create a copy of Filters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? years = null,
  }) {
    return _then(_$FiltersImpl(
      years: null == years
          ? _value._years
          : years // ignore: cast_nullable_to_non_nullable
              as List<FiltersYearModel>,
    ));
  }
}

/// @nodoc

class _$FiltersImpl implements _Filters {
  const _$FiltersImpl({required final List<FiltersYearModel> years})
      : _years = years;

  final List<FiltersYearModel> _years;
  @override
  List<FiltersYearModel> get years {
    if (_years is EqualUnmodifiableListView) return _years;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_years);
  }

  @override
  String toString() {
    return 'Filters(years: $years)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FiltersImpl &&
            const DeepCollectionEquality().equals(other._years, _years));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_years));

  /// Create a copy of Filters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FiltersImplCopyWith<_$FiltersImpl> get copyWith =>
      __$$FiltersImplCopyWithImpl<_$FiltersImpl>(this, _$identity);
}

abstract class _Filters implements Filters {
  const factory _Filters({required final List<FiltersYearModel> years}) =
      _$FiltersImpl;

  @override
  List<FiltersYearModel> get years;

  /// Create a copy of Filters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FiltersImplCopyWith<_$FiltersImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FiltersYearModel {
  int get from => throw _privateConstructorUsedError;
  int get to => throw _privateConstructorUsedError;
  String get filter => throw _privateConstructorUsedError;
  int get decade => throw _privateConstructorUsedError;
  List<YearYear> get years => throw _privateConstructorUsedError;
  bool get noFollow => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;

  /// Create a copy of FiltersYearModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FiltersYearModelCopyWith<FiltersYearModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FiltersYearModelCopyWith<$Res> {
  factory $FiltersYearModelCopyWith(
          FiltersYearModel value, $Res Function(FiltersYearModel) then) =
      _$FiltersYearModelCopyWithImpl<$Res, FiltersYearModel>;
  @useResult
  $Res call(
      {int from,
      int to,
      String filter,
      int decade,
      List<YearYear> years,
      bool noFollow,
      int count});
}

/// @nodoc
class _$FiltersYearModelCopyWithImpl<$Res, $Val extends FiltersYearModel>
    implements $FiltersYearModelCopyWith<$Res> {
  _$FiltersYearModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FiltersYearModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? from = null,
    Object? to = null,
    Object? filter = null,
    Object? decade = null,
    Object? years = null,
    Object? noFollow = null,
    Object? count = null,
  }) {
    return _then(_value.copyWith(
      from: null == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as int,
      to: null == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as int,
      filter: null == filter
          ? _value.filter
          : filter // ignore: cast_nullable_to_non_nullable
              as String,
      decade: null == decade
          ? _value.decade
          : decade // ignore: cast_nullable_to_non_nullable
              as int,
      years: null == years
          ? _value.years
          : years // ignore: cast_nullable_to_non_nullable
              as List<YearYear>,
      noFollow: null == noFollow
          ? _value.noFollow
          : noFollow // ignore: cast_nullable_to_non_nullable
              as bool,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FiltersYearModelImplCopyWith<$Res>
    implements $FiltersYearModelCopyWith<$Res> {
  factory _$$FiltersYearModelImplCopyWith(_$FiltersYearModelImpl value,
          $Res Function(_$FiltersYearModelImpl) then) =
      __$$FiltersYearModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int from,
      int to,
      String filter,
      int decade,
      List<YearYear> years,
      bool noFollow,
      int count});
}

/// @nodoc
class __$$FiltersYearModelImplCopyWithImpl<$Res>
    extends _$FiltersYearModelCopyWithImpl<$Res, _$FiltersYearModelImpl>
    implements _$$FiltersYearModelImplCopyWith<$Res> {
  __$$FiltersYearModelImplCopyWithImpl(_$FiltersYearModelImpl _value,
      $Res Function(_$FiltersYearModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of FiltersYearModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? from = null,
    Object? to = null,
    Object? filter = null,
    Object? decade = null,
    Object? years = null,
    Object? noFollow = null,
    Object? count = null,
  }) {
    return _then(_$FiltersYearModelImpl(
      from: null == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as int,
      to: null == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as int,
      filter: null == filter
          ? _value.filter
          : filter // ignore: cast_nullable_to_non_nullable
              as String,
      decade: null == decade
          ? _value.decade
          : decade // ignore: cast_nullable_to_non_nullable
              as int,
      years: null == years
          ? _value._years
          : years // ignore: cast_nullable_to_non_nullable
              as List<YearYear>,
      noFollow: null == noFollow
          ? _value.noFollow
          : noFollow // ignore: cast_nullable_to_non_nullable
              as bool,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FiltersYearModelImpl implements _FiltersYearModel {
  const _$FiltersYearModelImpl(
      {required this.from,
      required this.to,
      required this.filter,
      required this.decade,
      required final List<YearYear> years,
      required this.noFollow,
      required this.count})
      : _years = years;

  @override
  final int from;
  @override
  final int to;
  @override
  final String filter;
  @override
  final int decade;
  final List<YearYear> _years;
  @override
  List<YearYear> get years {
    if (_years is EqualUnmodifiableListView) return _years;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_years);
  }

  @override
  final bool noFollow;
  @override
  final int count;

  @override
  String toString() {
    return 'FiltersYearModel(from: $from, to: $to, filter: $filter, decade: $decade, years: $years, noFollow: $noFollow, count: $count)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FiltersYearModelImpl &&
            (identical(other.from, from) || other.from == from) &&
            (identical(other.to, to) || other.to == to) &&
            (identical(other.filter, filter) || other.filter == filter) &&
            (identical(other.decade, decade) || other.decade == decade) &&
            const DeepCollectionEquality().equals(other._years, _years) &&
            (identical(other.noFollow, noFollow) ||
                other.noFollow == noFollow) &&
            (identical(other.count, count) || other.count == count));
  }

  @override
  int get hashCode => Object.hash(runtimeType, from, to, filter, decade,
      const DeepCollectionEquality().hash(_years), noFollow, count);

  /// Create a copy of FiltersYearModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FiltersYearModelImplCopyWith<_$FiltersYearModelImpl> get copyWith =>
      __$$FiltersYearModelImplCopyWithImpl<_$FiltersYearModelImpl>(
          this, _$identity);
}

abstract class _FiltersYearModel implements FiltersYearModel {
  const factory _FiltersYearModel(
      {required final int from,
      required final int to,
      required final String filter,
      required final int decade,
      required final List<YearYear> years,
      required final bool noFollow,
      required final int count}) = _$FiltersYearModelImpl;

  @override
  int get from;
  @override
  int get to;
  @override
  String get filter;
  @override
  int get decade;
  @override
  List<YearYear> get years;
  @override
  bool get noFollow;
  @override
  int get count;

  /// Create a copy of FiltersYearModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FiltersYearModelImplCopyWith<_$FiltersYearModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$YearYear {
  int get year => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;
  bool get noFollow => throw _privateConstructorUsedError;

  /// Create a copy of YearYear
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $YearYearCopyWith<YearYear> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $YearYearCopyWith<$Res> {
  factory $YearYearCopyWith(YearYear value, $Res Function(YearYear) then) =
      _$YearYearCopyWithImpl<$Res, YearYear>;
  @useResult
  $Res call({int year, int count, bool noFollow});
}

/// @nodoc
class _$YearYearCopyWithImpl<$Res, $Val extends YearYear>
    implements $YearYearCopyWith<$Res> {
  _$YearYearCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of YearYear
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? year = null,
    Object? count = null,
    Object? noFollow = null,
  }) {
    return _then(_value.copyWith(
      year: null == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      noFollow: null == noFollow
          ? _value.noFollow
          : noFollow // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$YearYearImplCopyWith<$Res>
    implements $YearYearCopyWith<$Res> {
  factory _$$YearYearImplCopyWith(
          _$YearYearImpl value, $Res Function(_$YearYearImpl) then) =
      __$$YearYearImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int year, int count, bool noFollow});
}

/// @nodoc
class __$$YearYearImplCopyWithImpl<$Res>
    extends _$YearYearCopyWithImpl<$Res, _$YearYearImpl>
    implements _$$YearYearImplCopyWith<$Res> {
  __$$YearYearImplCopyWithImpl(
      _$YearYearImpl _value, $Res Function(_$YearYearImpl) _then)
      : super(_value, _then);

  /// Create a copy of YearYear
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? year = null,
    Object? count = null,
    Object? noFollow = null,
  }) {
    return _then(_$YearYearImpl(
      year: null == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      noFollow: null == noFollow
          ? _value.noFollow
          : noFollow // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$YearYearImpl implements _YearYear {
  const _$YearYearImpl(
      {required this.year, required this.count, required this.noFollow});

  @override
  final int year;
  @override
  final int count;
  @override
  final bool noFollow;

  @override
  String toString() {
    return 'YearYear(year: $year, count: $count, noFollow: $noFollow)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$YearYearImpl &&
            (identical(other.year, year) || other.year == year) &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.noFollow, noFollow) ||
                other.noFollow == noFollow));
  }

  @override
  int get hashCode => Object.hash(runtimeType, year, count, noFollow);

  /// Create a copy of YearYear
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$YearYearImplCopyWith<_$YearYearImpl> get copyWith =>
      __$$YearYearImplCopyWithImpl<_$YearYearImpl>(this, _$identity);
}

abstract class _YearYear implements YearYear {
  const factory _YearYear(
      {required final int year,
      required final int count,
      required final bool noFollow}) = _$YearYearImpl;

  @override
  int get year;
  @override
  int get count;
  @override
  bool get noFollow;

  /// Create a copy of YearYear
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$YearYearImplCopyWith<_$YearYearImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Games {
  int get id => throw _privateConstructorUsedError;
  String get slug => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  DateTime get released => throw _privateConstructorUsedError;

  /// Create a copy of Games
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GamesCopyWith<Games> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GamesCopyWith<$Res> {
  factory $GamesCopyWith(Games value, $Res Function(Games) then) =
      _$GamesCopyWithImpl<$Res, Games>;
  @useResult
  $Res call({int id, String slug, String name, DateTime released});
}

/// @nodoc
class _$GamesCopyWithImpl<$Res, $Val extends Games>
    implements $GamesCopyWith<$Res> {
  _$GamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Games
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? slug = null,
    Object? name = null,
    Object? released = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      released: null == released
          ? _value.released
          : released // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GamesImplCopyWith<$Res> implements $GamesCopyWith<$Res> {
  factory _$$GamesImplCopyWith(
          _$GamesImpl value, $Res Function(_$GamesImpl) then) =
      __$$GamesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, String slug, String name, DateTime released});
}

/// @nodoc
class __$$GamesImplCopyWithImpl<$Res>
    extends _$GamesCopyWithImpl<$Res, _$GamesImpl>
    implements _$$GamesImplCopyWith<$Res> {
  __$$GamesImplCopyWithImpl(
      _$GamesImpl _value, $Res Function(_$GamesImpl) _then)
      : super(_value, _then);

  /// Create a copy of Games
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? slug = null,
    Object? name = null,
    Object? released = null,
  }) {
    return _then(_$GamesImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      released: null == released
          ? _value.released
          : released // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$GamesImpl implements _Games {
  const _$GamesImpl(
      {required this.id,
      required this.slug,
      required this.name,
      required this.released});

  @override
  final int id;
  @override
  final String slug;
  @override
  final String name;
  @override
  final DateTime released;

  @override
  String toString() {
    return 'Games(id: $id, slug: $slug, name: $name, released: $released)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GamesImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.slug, slug) || other.slug == slug) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.released, released) ||
                other.released == released));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, slug, name, released);

  /// Create a copy of Games
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GamesImplCopyWith<_$GamesImpl> get copyWith =>
      __$$GamesImplCopyWithImpl<_$GamesImpl>(this, _$identity);
}

abstract class _Games implements Games {
  const factory _Games(
      {required final int id,
      required final String slug,
      required final String name,
      required final DateTime released}) = _$GamesImpl;

  @override
  int get id;
  @override
  String get slug;
  @override
  String get name;
  @override
  DateTime get released;

  /// Create a copy of Games
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GamesImplCopyWith<_$GamesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddedByStatus {
  int get yet => throw _privateConstructorUsedError;
  int get owned => throw _privateConstructorUsedError;
  int get beaten => throw _privateConstructorUsedError;
  int get toPlay => throw _privateConstructorUsedError;
  int get dropped => throw _privateConstructorUsedError;
  int get playing => throw _privateConstructorUsedError;

  /// Create a copy of AddedByStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AddedByStatusCopyWith<AddedByStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddedByStatusCopyWith<$Res> {
  factory $AddedByStatusCopyWith(
          AddedByStatus value, $Res Function(AddedByStatus) then) =
      _$AddedByStatusCopyWithImpl<$Res, AddedByStatus>;
  @useResult
  $Res call(
      {int yet, int owned, int beaten, int toPlay, int dropped, int playing});
}

/// @nodoc
class _$AddedByStatusCopyWithImpl<$Res, $Val extends AddedByStatus>
    implements $AddedByStatusCopyWith<$Res> {
  _$AddedByStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddedByStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? yet = null,
    Object? owned = null,
    Object? beaten = null,
    Object? toPlay = null,
    Object? dropped = null,
    Object? playing = null,
  }) {
    return _then(_value.copyWith(
      yet: null == yet
          ? _value.yet
          : yet // ignore: cast_nullable_to_non_nullable
              as int,
      owned: null == owned
          ? _value.owned
          : owned // ignore: cast_nullable_to_non_nullable
              as int,
      beaten: null == beaten
          ? _value.beaten
          : beaten // ignore: cast_nullable_to_non_nullable
              as int,
      toPlay: null == toPlay
          ? _value.toPlay
          : toPlay // ignore: cast_nullable_to_non_nullable
              as int,
      dropped: null == dropped
          ? _value.dropped
          : dropped // ignore: cast_nullable_to_non_nullable
              as int,
      playing: null == playing
          ? _value.playing
          : playing // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AddedByStatusImplCopyWith<$Res>
    implements $AddedByStatusCopyWith<$Res> {
  factory _$$AddedByStatusImplCopyWith(
          _$AddedByStatusImpl value, $Res Function(_$AddedByStatusImpl) then) =
      __$$AddedByStatusImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int yet, int owned, int beaten, int toPlay, int dropped, int playing});
}

/// @nodoc
class __$$AddedByStatusImplCopyWithImpl<$Res>
    extends _$AddedByStatusCopyWithImpl<$Res, _$AddedByStatusImpl>
    implements _$$AddedByStatusImplCopyWith<$Res> {
  __$$AddedByStatusImplCopyWithImpl(
      _$AddedByStatusImpl _value, $Res Function(_$AddedByStatusImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddedByStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? yet = null,
    Object? owned = null,
    Object? beaten = null,
    Object? toPlay = null,
    Object? dropped = null,
    Object? playing = null,
  }) {
    return _then(_$AddedByStatusImpl(
      yet: null == yet
          ? _value.yet
          : yet // ignore: cast_nullable_to_non_nullable
              as int,
      owned: null == owned
          ? _value.owned
          : owned // ignore: cast_nullable_to_non_nullable
              as int,
      beaten: null == beaten
          ? _value.beaten
          : beaten // ignore: cast_nullable_to_non_nullable
              as int,
      toPlay: null == toPlay
          ? _value.toPlay
          : toPlay // ignore: cast_nullable_to_non_nullable
              as int,
      dropped: null == dropped
          ? _value.dropped
          : dropped // ignore: cast_nullable_to_non_nullable
              as int,
      playing: null == playing
          ? _value.playing
          : playing // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddedByStatusImpl implements _AddedByStatus {
  const _$AddedByStatusImpl(
      {required this.yet,
      required this.owned,
      required this.beaten,
      required this.toPlay,
      required this.dropped,
      required this.playing});

  @override
  final int yet;
  @override
  final int owned;
  @override
  final int beaten;
  @override
  final int toPlay;
  @override
  final int dropped;
  @override
  final int playing;

  @override
  String toString() {
    return 'AddedByStatus(yet: $yet, owned: $owned, beaten: $beaten, toPlay: $toPlay, dropped: $dropped, playing: $playing)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddedByStatusImpl &&
            (identical(other.yet, yet) || other.yet == yet) &&
            (identical(other.owned, owned) || other.owned == owned) &&
            (identical(other.beaten, beaten) || other.beaten == beaten) &&
            (identical(other.toPlay, toPlay) || other.toPlay == toPlay) &&
            (identical(other.dropped, dropped) || other.dropped == dropped) &&
            (identical(other.playing, playing) || other.playing == playing));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, yet, owned, beaten, toPlay, dropped, playing);

  /// Create a copy of AddedByStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddedByStatusImplCopyWith<_$AddedByStatusImpl> get copyWith =>
      __$$AddedByStatusImplCopyWithImpl<_$AddedByStatusImpl>(this, _$identity);
}

abstract class _AddedByStatus implements AddedByStatus {
  const factory _AddedByStatus(
      {required final int yet,
      required final int owned,
      required final int beaten,
      required final int toPlay,
      required final int dropped,
      required final int playing}) = _$AddedByStatusImpl;

  @override
  int get yet;
  @override
  int get owned;
  @override
  int get beaten;
  @override
  int get toPlay;
  @override
  int get dropped;
  @override
  int get playing;

  /// Create a copy of AddedByStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddedByStatusImplCopyWith<_$AddedByStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EsrbRating {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get slug => throw _privateConstructorUsedError;

  /// Create a copy of EsrbRating
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EsrbRatingCopyWith<EsrbRating> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EsrbRatingCopyWith<$Res> {
  factory $EsrbRatingCopyWith(
          EsrbRating value, $Res Function(EsrbRating) then) =
      _$EsrbRatingCopyWithImpl<$Res, EsrbRating>;
  @useResult
  $Res call({int id, String name, String slug});
}

/// @nodoc
class _$EsrbRatingCopyWithImpl<$Res, $Val extends EsrbRating>
    implements $EsrbRatingCopyWith<$Res> {
  _$EsrbRatingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EsrbRating
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? slug = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EsrbRatingImplCopyWith<$Res>
    implements $EsrbRatingCopyWith<$Res> {
  factory _$$EsrbRatingImplCopyWith(
          _$EsrbRatingImpl value, $Res Function(_$EsrbRatingImpl) then) =
      __$$EsrbRatingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, String name, String slug});
}

/// @nodoc
class __$$EsrbRatingImplCopyWithImpl<$Res>
    extends _$EsrbRatingCopyWithImpl<$Res, _$EsrbRatingImpl>
    implements _$$EsrbRatingImplCopyWith<$Res> {
  __$$EsrbRatingImplCopyWithImpl(
      _$EsrbRatingImpl _value, $Res Function(_$EsrbRatingImpl) _then)
      : super(_value, _then);

  /// Create a copy of EsrbRating
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? slug = null,
  }) {
    return _then(_$EsrbRatingImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EsrbRatingImpl implements _EsrbRating {
  const _$EsrbRatingImpl(
      {required this.id, required this.name, required this.slug});

  @override
  final int id;
  @override
  final String name;
  @override
  final String slug;

  @override
  String toString() {
    return 'EsrbRating(id: $id, name: $name, slug: $slug)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EsrbRatingImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.slug, slug) || other.slug == slug));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, name, slug);

  /// Create a copy of EsrbRating
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EsrbRatingImplCopyWith<_$EsrbRatingImpl> get copyWith =>
      __$$EsrbRatingImplCopyWithImpl<_$EsrbRatingImpl>(this, _$identity);
}

abstract class _EsrbRating implements EsrbRating {
  const factory _EsrbRating(
      {required final int id,
      required final String name,
      required final String slug}) = _$EsrbRatingImpl;

  @override
  int get id;
  @override
  String get name;
  @override
  String get slug;

  /// Create a copy of EsrbRating
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EsrbRatingImplCopyWith<_$EsrbRatingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Genres {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get slug => throw _privateConstructorUsedError;
  int get gamesCount => throw _privateConstructorUsedError;
  String get imageBackground => throw _privateConstructorUsedError;
  Domain get domain => throw _privateConstructorUsedError;
  Language get language => throw _privateConstructorUsedError;

  /// Create a copy of Genres
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GenresCopyWith<Genres> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenresCopyWith<$Res> {
  factory $GenresCopyWith(Genres value, $Res Function(Genres) then) =
      _$GenresCopyWithImpl<$Res, Genres>;
  @useResult
  $Res call(
      {int id,
      String name,
      String slug,
      int gamesCount,
      String imageBackground,
      Domain domain,
      Language language});
}

/// @nodoc
class _$GenresCopyWithImpl<$Res, $Val extends Genres>
    implements $GenresCopyWith<$Res> {
  _$GenresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Genres
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? slug = null,
    Object? gamesCount = null,
    Object? imageBackground = null,
    Object? domain = null,
    Object? language = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      gamesCount: null == gamesCount
          ? _value.gamesCount
          : gamesCount // ignore: cast_nullable_to_non_nullable
              as int,
      imageBackground: null == imageBackground
          ? _value.imageBackground
          : imageBackground // ignore: cast_nullable_to_non_nullable
              as String,
      domain: null == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as Domain,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GenresImplCopyWith<$Res> implements $GenresCopyWith<$Res> {
  factory _$$GenresImplCopyWith(
          _$GenresImpl value, $Res Function(_$GenresImpl) then) =
      __$$GenresImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String name,
      String slug,
      int gamesCount,
      String imageBackground,
      Domain domain,
      Language language});
}

/// @nodoc
class __$$GenresImplCopyWithImpl<$Res>
    extends _$GenresCopyWithImpl<$Res, _$GenresImpl>
    implements _$$GenresImplCopyWith<$Res> {
  __$$GenresImplCopyWithImpl(
      _$GenresImpl _value, $Res Function(_$GenresImpl) _then)
      : super(_value, _then);

  /// Create a copy of Genres
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? slug = null,
    Object? gamesCount = null,
    Object? imageBackground = null,
    Object? domain = null,
    Object? language = null,
  }) {
    return _then(_$GenresImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      gamesCount: null == gamesCount
          ? _value.gamesCount
          : gamesCount // ignore: cast_nullable_to_non_nullable
              as int,
      imageBackground: null == imageBackground
          ? _value.imageBackground
          : imageBackground // ignore: cast_nullable_to_non_nullable
              as String,
      domain: null == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as Domain,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
    ));
  }
}

/// @nodoc

class _$GenresImpl implements _Genres {
  const _$GenresImpl(
      {required this.id,
      required this.name,
      required this.slug,
      required this.gamesCount,
      required this.imageBackground,
      required this.domain,
      required this.language});

  @override
  final int id;
  @override
  final String name;
  @override
  final String slug;
  @override
  final int gamesCount;
  @override
  final String imageBackground;
  @override
  final Domain domain;
  @override
  final Language language;

  @override
  String toString() {
    return 'Genres(id: $id, name: $name, slug: $slug, gamesCount: $gamesCount, imageBackground: $imageBackground, domain: $domain, language: $language)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenresImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.slug, slug) || other.slug == slug) &&
            (identical(other.gamesCount, gamesCount) ||
                other.gamesCount == gamesCount) &&
            (identical(other.imageBackground, imageBackground) ||
                other.imageBackground == imageBackground) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, name, slug, gamesCount,
      imageBackground, domain, language);

  /// Create a copy of Genres
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GenresImplCopyWith<_$GenresImpl> get copyWith =>
      __$$GenresImplCopyWithImpl<_$GenresImpl>(this, _$identity);
}

abstract class _Genres implements Genres {
  const factory _Genres(
      {required final int id,
      required final String name,
      required final String slug,
      required final int gamesCount,
      required final String imageBackground,
      required final Domain domain,
      required final Language language}) = _$GenresImpl;

  @override
  int get id;
  @override
  String get name;
  @override
  String get slug;
  @override
  int get gamesCount;
  @override
  String get imageBackground;
  @override
  Domain get domain;
  @override
  Language get language;

  /// Create a copy of Genres
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GenresImplCopyWith<_$GenresImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ParentPlatform {
  EsrbRating get platform => throw _privateConstructorUsedError;

  /// Create a copy of ParentPlatform
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ParentPlatformCopyWith<ParentPlatform> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParentPlatformCopyWith<$Res> {
  factory $ParentPlatformCopyWith(
          ParentPlatform value, $Res Function(ParentPlatform) then) =
      _$ParentPlatformCopyWithImpl<$Res, ParentPlatform>;
  @useResult
  $Res call({EsrbRating platform});

  $EsrbRatingCopyWith<$Res> get platform;
}

/// @nodoc
class _$ParentPlatformCopyWithImpl<$Res, $Val extends ParentPlatform>
    implements $ParentPlatformCopyWith<$Res> {
  _$ParentPlatformCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ParentPlatform
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? platform = null,
  }) {
    return _then(_value.copyWith(
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as EsrbRating,
    ) as $Val);
  }

  /// Create a copy of ParentPlatform
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EsrbRatingCopyWith<$Res> get platform {
    return $EsrbRatingCopyWith<$Res>(_value.platform, (value) {
      return _then(_value.copyWith(platform: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ParentPlatformImplCopyWith<$Res>
    implements $ParentPlatformCopyWith<$Res> {
  factory _$$ParentPlatformImplCopyWith(_$ParentPlatformImpl value,
          $Res Function(_$ParentPlatformImpl) then) =
      __$$ParentPlatformImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EsrbRating platform});

  @override
  $EsrbRatingCopyWith<$Res> get platform;
}

/// @nodoc
class __$$ParentPlatformImplCopyWithImpl<$Res>
    extends _$ParentPlatformCopyWithImpl<$Res, _$ParentPlatformImpl>
    implements _$$ParentPlatformImplCopyWith<$Res> {
  __$$ParentPlatformImplCopyWithImpl(
      _$ParentPlatformImpl _value, $Res Function(_$ParentPlatformImpl) _then)
      : super(_value, _then);

  /// Create a copy of ParentPlatform
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? platform = null,
  }) {
    return _then(_$ParentPlatformImpl(
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as EsrbRating,
    ));
  }
}

/// @nodoc

class _$ParentPlatformImpl implements _ParentPlatform {
  const _$ParentPlatformImpl({required this.platform});

  @override
  final EsrbRating platform;

  @override
  String toString() {
    return 'ParentPlatform(platform: $platform)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParentPlatformImpl &&
            (identical(other.platform, platform) ||
                other.platform == platform));
  }

  @override
  int get hashCode => Object.hash(runtimeType, platform);

  /// Create a copy of ParentPlatform
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ParentPlatformImplCopyWith<_$ParentPlatformImpl> get copyWith =>
      __$$ParentPlatformImplCopyWithImpl<_$ParentPlatformImpl>(
          this, _$identity);
}

abstract class _ParentPlatform implements ParentPlatform {
  const factory _ParentPlatform({required final EsrbRating platform}) =
      _$ParentPlatformImpl;

  @override
  EsrbRating get platform;

  /// Create a copy of ParentPlatform
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ParentPlatformImplCopyWith<_$ParentPlatformImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PlatformElement {
  PlatformPlatform get platform => throw _privateConstructorUsedError;
  DateTime get releasedAt => throw _privateConstructorUsedError;
  Requirements get requirementsEn => throw _privateConstructorUsedError;
  Requirements get requirementsRu => throw _privateConstructorUsedError;

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PlatformElementCopyWith<PlatformElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlatformElementCopyWith<$Res> {
  factory $PlatformElementCopyWith(
          PlatformElement value, $Res Function(PlatformElement) then) =
      _$PlatformElementCopyWithImpl<$Res, PlatformElement>;
  @useResult
  $Res call(
      {PlatformPlatform platform,
      DateTime releasedAt,
      Requirements requirementsEn,
      Requirements requirementsRu});

  $PlatformPlatformCopyWith<$Res> get platform;
  $RequirementsCopyWith<$Res> get requirementsEn;
  $RequirementsCopyWith<$Res> get requirementsRu;
}

/// @nodoc
class _$PlatformElementCopyWithImpl<$Res, $Val extends PlatformElement>
    implements $PlatformElementCopyWith<$Res> {
  _$PlatformElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? platform = null,
    Object? releasedAt = null,
    Object? requirementsEn = null,
    Object? requirementsRu = null,
  }) {
    return _then(_value.copyWith(
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as PlatformPlatform,
      releasedAt: null == releasedAt
          ? _value.releasedAt
          : releasedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      requirementsEn: null == requirementsEn
          ? _value.requirementsEn
          : requirementsEn // ignore: cast_nullable_to_non_nullable
              as Requirements,
      requirementsRu: null == requirementsRu
          ? _value.requirementsRu
          : requirementsRu // ignore: cast_nullable_to_non_nullable
              as Requirements,
    ) as $Val);
  }

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PlatformPlatformCopyWith<$Res> get platform {
    return $PlatformPlatformCopyWith<$Res>(_value.platform, (value) {
      return _then(_value.copyWith(platform: value) as $Val);
    });
  }

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RequirementsCopyWith<$Res> get requirementsEn {
    return $RequirementsCopyWith<$Res>(_value.requirementsEn, (value) {
      return _then(_value.copyWith(requirementsEn: value) as $Val);
    });
  }

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RequirementsCopyWith<$Res> get requirementsRu {
    return $RequirementsCopyWith<$Res>(_value.requirementsRu, (value) {
      return _then(_value.copyWith(requirementsRu: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PlatformElementImplCopyWith<$Res>
    implements $PlatformElementCopyWith<$Res> {
  factory _$$PlatformElementImplCopyWith(_$PlatformElementImpl value,
          $Res Function(_$PlatformElementImpl) then) =
      __$$PlatformElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PlatformPlatform platform,
      DateTime releasedAt,
      Requirements requirementsEn,
      Requirements requirementsRu});

  @override
  $PlatformPlatformCopyWith<$Res> get platform;
  @override
  $RequirementsCopyWith<$Res> get requirementsEn;
  @override
  $RequirementsCopyWith<$Res> get requirementsRu;
}

/// @nodoc
class __$$PlatformElementImplCopyWithImpl<$Res>
    extends _$PlatformElementCopyWithImpl<$Res, _$PlatformElementImpl>
    implements _$$PlatformElementImplCopyWith<$Res> {
  __$$PlatformElementImplCopyWithImpl(
      _$PlatformElementImpl _value, $Res Function(_$PlatformElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? platform = null,
    Object? releasedAt = null,
    Object? requirementsEn = null,
    Object? requirementsRu = null,
  }) {
    return _then(_$PlatformElementImpl(
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as PlatformPlatform,
      releasedAt: null == releasedAt
          ? _value.releasedAt
          : releasedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      requirementsEn: null == requirementsEn
          ? _value.requirementsEn
          : requirementsEn // ignore: cast_nullable_to_non_nullable
              as Requirements,
      requirementsRu: null == requirementsRu
          ? _value.requirementsRu
          : requirementsRu // ignore: cast_nullable_to_non_nullable
              as Requirements,
    ));
  }
}

/// @nodoc

class _$PlatformElementImpl implements _PlatformElement {
  const _$PlatformElementImpl(
      {required this.platform,
      required this.releasedAt,
      required this.requirementsEn,
      required this.requirementsRu});

  @override
  final PlatformPlatform platform;
  @override
  final DateTime releasedAt;
  @override
  final Requirements requirementsEn;
  @override
  final Requirements requirementsRu;

  @override
  String toString() {
    return 'PlatformElement(platform: $platform, releasedAt: $releasedAt, requirementsEn: $requirementsEn, requirementsRu: $requirementsRu)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlatformElementImpl &&
            (identical(other.platform, platform) ||
                other.platform == platform) &&
            (identical(other.releasedAt, releasedAt) ||
                other.releasedAt == releasedAt) &&
            (identical(other.requirementsEn, requirementsEn) ||
                other.requirementsEn == requirementsEn) &&
            (identical(other.requirementsRu, requirementsRu) ||
                other.requirementsRu == requirementsRu));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, platform, releasedAt, requirementsEn, requirementsRu);

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlatformElementImplCopyWith<_$PlatformElementImpl> get copyWith =>
      __$$PlatformElementImplCopyWithImpl<_$PlatformElementImpl>(
          this, _$identity);
}

abstract class _PlatformElement implements PlatformElement {
  const factory _PlatformElement(
      {required final PlatformPlatform platform,
      required final DateTime releasedAt,
      required final Requirements requirementsEn,
      required final Requirements requirementsRu}) = _$PlatformElementImpl;

  @override
  PlatformPlatform get platform;
  @override
  DateTime get releasedAt;
  @override
  Requirements get requirementsEn;
  @override
  Requirements get requirementsRu;

  /// Create a copy of PlatformElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlatformElementImplCopyWith<_$PlatformElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PlatformPlatform {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get slug => throw _privateConstructorUsedError;
  dynamic get image => throw _privateConstructorUsedError;
  dynamic get yearEnd => throw _privateConstructorUsedError;
  int get yearStart => throw _privateConstructorUsedError;
  int get gamesCount => throw _privateConstructorUsedError;
  String get imageBackground => throw _privateConstructorUsedError;

  /// Create a copy of PlatformPlatform
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PlatformPlatformCopyWith<PlatformPlatform> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlatformPlatformCopyWith<$Res> {
  factory $PlatformPlatformCopyWith(
          PlatformPlatform value, $Res Function(PlatformPlatform) then) =
      _$PlatformPlatformCopyWithImpl<$Res, PlatformPlatform>;
  @useResult
  $Res call(
      {int id,
      String name,
      String slug,
      dynamic image,
      dynamic yearEnd,
      int yearStart,
      int gamesCount,
      String imageBackground});
}

/// @nodoc
class _$PlatformPlatformCopyWithImpl<$Res, $Val extends PlatformPlatform>
    implements $PlatformPlatformCopyWith<$Res> {
  _$PlatformPlatformCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PlatformPlatform
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? slug = null,
    Object? image = freezed,
    Object? yearEnd = freezed,
    Object? yearStart = null,
    Object? gamesCount = null,
    Object? imageBackground = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as dynamic,
      yearEnd: freezed == yearEnd
          ? _value.yearEnd
          : yearEnd // ignore: cast_nullable_to_non_nullable
              as dynamic,
      yearStart: null == yearStart
          ? _value.yearStart
          : yearStart // ignore: cast_nullable_to_non_nullable
              as int,
      gamesCount: null == gamesCount
          ? _value.gamesCount
          : gamesCount // ignore: cast_nullable_to_non_nullable
              as int,
      imageBackground: null == imageBackground
          ? _value.imageBackground
          : imageBackground // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PlatformPlatformImplCopyWith<$Res>
    implements $PlatformPlatformCopyWith<$Res> {
  factory _$$PlatformPlatformImplCopyWith(_$PlatformPlatformImpl value,
          $Res Function(_$PlatformPlatformImpl) then) =
      __$$PlatformPlatformImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String name,
      String slug,
      dynamic image,
      dynamic yearEnd,
      int yearStart,
      int gamesCount,
      String imageBackground});
}

/// @nodoc
class __$$PlatformPlatformImplCopyWithImpl<$Res>
    extends _$PlatformPlatformCopyWithImpl<$Res, _$PlatformPlatformImpl>
    implements _$$PlatformPlatformImplCopyWith<$Res> {
  __$$PlatformPlatformImplCopyWithImpl(_$PlatformPlatformImpl _value,
      $Res Function(_$PlatformPlatformImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlatformPlatform
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? slug = null,
    Object? image = freezed,
    Object? yearEnd = freezed,
    Object? yearStart = null,
    Object? gamesCount = null,
    Object? imageBackground = null,
  }) {
    return _then(_$PlatformPlatformImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as dynamic,
      yearEnd: freezed == yearEnd
          ? _value.yearEnd
          : yearEnd // ignore: cast_nullable_to_non_nullable
              as dynamic,
      yearStart: null == yearStart
          ? _value.yearStart
          : yearStart // ignore: cast_nullable_to_non_nullable
              as int,
      gamesCount: null == gamesCount
          ? _value.gamesCount
          : gamesCount // ignore: cast_nullable_to_non_nullable
              as int,
      imageBackground: null == imageBackground
          ? _value.imageBackground
          : imageBackground // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PlatformPlatformImpl implements _PlatformPlatform {
  const _$PlatformPlatformImpl(
      {required this.id,
      required this.name,
      required this.slug,
      required this.image,
      required this.yearEnd,
      required this.yearStart,
      required this.gamesCount,
      required this.imageBackground});

  @override
  final int id;
  @override
  final String name;
  @override
  final String slug;
  @override
  final dynamic image;
  @override
  final dynamic yearEnd;
  @override
  final int yearStart;
  @override
  final int gamesCount;
  @override
  final String imageBackground;

  @override
  String toString() {
    return 'PlatformPlatform(id: $id, name: $name, slug: $slug, image: $image, yearEnd: $yearEnd, yearStart: $yearStart, gamesCount: $gamesCount, imageBackground: $imageBackground)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlatformPlatformImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.slug, slug) || other.slug == slug) &&
            const DeepCollectionEquality().equals(other.image, image) &&
            const DeepCollectionEquality().equals(other.yearEnd, yearEnd) &&
            (identical(other.yearStart, yearStart) ||
                other.yearStart == yearStart) &&
            (identical(other.gamesCount, gamesCount) ||
                other.gamesCount == gamesCount) &&
            (identical(other.imageBackground, imageBackground) ||
                other.imageBackground == imageBackground));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      slug,
      const DeepCollectionEquality().hash(image),
      const DeepCollectionEquality().hash(yearEnd),
      yearStart,
      gamesCount,
      imageBackground);

  /// Create a copy of PlatformPlatform
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PlatformPlatformImplCopyWith<_$PlatformPlatformImpl> get copyWith =>
      __$$PlatformPlatformImplCopyWithImpl<_$PlatformPlatformImpl>(
          this, _$identity);
}

abstract class _PlatformPlatform implements PlatformPlatform {
  const factory _PlatformPlatform(
      {required final int id,
      required final String name,
      required final String slug,
      required final dynamic image,
      required final dynamic yearEnd,
      required final int yearStart,
      required final int gamesCount,
      required final String imageBackground}) = _$PlatformPlatformImpl;

  @override
  int get id;
  @override
  String get name;
  @override
  String get slug;
  @override
  dynamic get image;
  @override
  dynamic get yearEnd;
  @override
  int get yearStart;
  @override
  int get gamesCount;
  @override
  String get imageBackground;

  /// Create a copy of PlatformPlatform
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PlatformPlatformImplCopyWith<_$PlatformPlatformImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Requirements {
  String get minimum => throw _privateConstructorUsedError;
  String get recommended => throw _privateConstructorUsedError;

  /// Create a copy of Requirements
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RequirementsCopyWith<Requirements> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequirementsCopyWith<$Res> {
  factory $RequirementsCopyWith(
          Requirements value, $Res Function(Requirements) then) =
      _$RequirementsCopyWithImpl<$Res, Requirements>;
  @useResult
  $Res call({String minimum, String recommended});
}

/// @nodoc
class _$RequirementsCopyWithImpl<$Res, $Val extends Requirements>
    implements $RequirementsCopyWith<$Res> {
  _$RequirementsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Requirements
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? minimum = null,
    Object? recommended = null,
  }) {
    return _then(_value.copyWith(
      minimum: null == minimum
          ? _value.minimum
          : minimum // ignore: cast_nullable_to_non_nullable
              as String,
      recommended: null == recommended
          ? _value.recommended
          : recommended // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RequirementsImplCopyWith<$Res>
    implements $RequirementsCopyWith<$Res> {
  factory _$$RequirementsImplCopyWith(
          _$RequirementsImpl value, $Res Function(_$RequirementsImpl) then) =
      __$$RequirementsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String minimum, String recommended});
}

/// @nodoc
class __$$RequirementsImplCopyWithImpl<$Res>
    extends _$RequirementsCopyWithImpl<$Res, _$RequirementsImpl>
    implements _$$RequirementsImplCopyWith<$Res> {
  __$$RequirementsImplCopyWithImpl(
      _$RequirementsImpl _value, $Res Function(_$RequirementsImpl) _then)
      : super(_value, _then);

  /// Create a copy of Requirements
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? minimum = null,
    Object? recommended = null,
  }) {
    return _then(_$RequirementsImpl(
      minimum: null == minimum
          ? _value.minimum
          : minimum // ignore: cast_nullable_to_non_nullable
              as String,
      recommended: null == recommended
          ? _value.recommended
          : recommended // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RequirementsImpl implements _Requirements {
  const _$RequirementsImpl({required this.minimum, required this.recommended});

  @override
  final String minimum;
  @override
  final String recommended;

  @override
  String toString() {
    return 'Requirements(minimum: $minimum, recommended: $recommended)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequirementsImpl &&
            (identical(other.minimum, minimum) || other.minimum == minimum) &&
            (identical(other.recommended, recommended) ||
                other.recommended == recommended));
  }

  @override
  int get hashCode => Object.hash(runtimeType, minimum, recommended);

  /// Create a copy of Requirements
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RequirementsImplCopyWith<_$RequirementsImpl> get copyWith =>
      __$$RequirementsImplCopyWithImpl<_$RequirementsImpl>(this, _$identity);
}

abstract class _Requirements implements Requirements {
  const factory _Requirements(
      {required final String minimum,
      required final String recommended}) = _$RequirementsImpl;

  @override
  String get minimum;
  @override
  String get recommended;

  /// Create a copy of Requirements
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RequirementsImplCopyWith<_$RequirementsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Rating {
  int get id => throw _privateConstructorUsedError;
  TitleModel get title => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;
  double get percent => throw _privateConstructorUsedError;

  /// Create a copy of Rating
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RatingCopyWith<Rating> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RatingCopyWith<$Res> {
  factory $RatingCopyWith(Rating value, $Res Function(Rating) then) =
      _$RatingCopyWithImpl<$Res, Rating>;
  @useResult
  $Res call({int id, TitleModel title, int count, double percent});
}

/// @nodoc
class _$RatingCopyWithImpl<$Res, $Val extends Rating>
    implements $RatingCopyWith<$Res> {
  _$RatingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Rating
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? count = null,
    Object? percent = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as TitleModel,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      percent: null == percent
          ? _value.percent
          : percent // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RatingImplCopyWith<$Res> implements $RatingCopyWith<$Res> {
  factory _$$RatingImplCopyWith(
          _$RatingImpl value, $Res Function(_$RatingImpl) then) =
      __$$RatingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, TitleModel title, int count, double percent});
}

/// @nodoc
class __$$RatingImplCopyWithImpl<$Res>
    extends _$RatingCopyWithImpl<$Res, _$RatingImpl>
    implements _$$RatingImplCopyWith<$Res> {
  __$$RatingImplCopyWithImpl(
      _$RatingImpl _value, $Res Function(_$RatingImpl) _then)
      : super(_value, _then);

  /// Create a copy of Rating
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? count = null,
    Object? percent = null,
  }) {
    return _then(_$RatingImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as TitleModel,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      percent: null == percent
          ? _value.percent
          : percent // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$RatingImpl implements _Rating {
  const _$RatingImpl(
      {required this.id,
      required this.title,
      required this.count,
      required this.percent});

  @override
  final int id;
  @override
  final TitleModel title;
  @override
  final int count;
  @override
  final double percent;

  @override
  String toString() {
    return 'Rating(id: $id, title: $title, count: $count, percent: $percent)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RatingImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.percent, percent) || other.percent == percent));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, title, count, percent);

  /// Create a copy of Rating
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RatingImplCopyWith<_$RatingImpl> get copyWith =>
      __$$RatingImplCopyWithImpl<_$RatingImpl>(this, _$identity);
}

abstract class _Rating implements Rating {
  const factory _Rating(
      {required final int id,
      required final TitleModel title,
      required final int count,
      required final double percent}) = _$RatingImpl;

  @override
  int get id;
  @override
  TitleModel get title;
  @override
  int get count;
  @override
  double get percent;

  /// Create a copy of Rating
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RatingImplCopyWith<_$RatingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ShortScreenshot {
  int get id => throw _privateConstructorUsedError;
  String get image => throw _privateConstructorUsedError;

  /// Create a copy of ShortScreenshot
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ShortScreenshotCopyWith<ShortScreenshot> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortScreenshotCopyWith<$Res> {
  factory $ShortScreenshotCopyWith(
          ShortScreenshot value, $Res Function(ShortScreenshot) then) =
      _$ShortScreenshotCopyWithImpl<$Res, ShortScreenshot>;
  @useResult
  $Res call({int id, String image});
}

/// @nodoc
class _$ShortScreenshotCopyWithImpl<$Res, $Val extends ShortScreenshot>
    implements $ShortScreenshotCopyWith<$Res> {
  _$ShortScreenshotCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ShortScreenshot
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? image = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ShortScreenshotImplCopyWith<$Res>
    implements $ShortScreenshotCopyWith<$Res> {
  factory _$$ShortScreenshotImplCopyWith(_$ShortScreenshotImpl value,
          $Res Function(_$ShortScreenshotImpl) then) =
      __$$ShortScreenshotImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, String image});
}

/// @nodoc
class __$$ShortScreenshotImplCopyWithImpl<$Res>
    extends _$ShortScreenshotCopyWithImpl<$Res, _$ShortScreenshotImpl>
    implements _$$ShortScreenshotImplCopyWith<$Res> {
  __$$ShortScreenshotImplCopyWithImpl(
      _$ShortScreenshotImpl _value, $Res Function(_$ShortScreenshotImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShortScreenshot
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? image = null,
  }) {
    return _then(_$ShortScreenshotImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ShortScreenshotImpl implements _ShortScreenshot {
  const _$ShortScreenshotImpl({required this.id, required this.image});

  @override
  final int id;
  @override
  final String image;

  @override
  String toString() {
    return 'ShortScreenshot(id: $id, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortScreenshotImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.image, image) || other.image == image));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, image);

  /// Create a copy of ShortScreenshot
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ShortScreenshotImplCopyWith<_$ShortScreenshotImpl> get copyWith =>
      __$$ShortScreenshotImplCopyWithImpl<_$ShortScreenshotImpl>(
          this, _$identity);
}

abstract class _ShortScreenshot implements ShortScreenshot {
  const factory _ShortScreenshot(
      {required final int id,
      required final String image}) = _$ShortScreenshotImpl;

  @override
  int get id;
  @override
  String get image;

  /// Create a copy of ShortScreenshot
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ShortScreenshotImplCopyWith<_$ShortScreenshotImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Store {
  int get id => throw _privateConstructorUsedError;
  Genres get store => throw _privateConstructorUsedError;

  /// Create a copy of Store
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoreCopyWith<Store> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoreCopyWith<$Res> {
  factory $StoreCopyWith(Store value, $Res Function(Store) then) =
      _$StoreCopyWithImpl<$Res, Store>;
  @useResult
  $Res call({int id, Genres store});

  $GenresCopyWith<$Res> get store;
}

/// @nodoc
class _$StoreCopyWithImpl<$Res, $Val extends Store>
    implements $StoreCopyWith<$Res> {
  _$StoreCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Store
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? store = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as Genres,
    ) as $Val);
  }

  /// Create a copy of Store
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GenresCopyWith<$Res> get store {
    return $GenresCopyWith<$Res>(_value.store, (value) {
      return _then(_value.copyWith(store: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$StoreImplCopyWith<$Res> implements $StoreCopyWith<$Res> {
  factory _$$StoreImplCopyWith(
          _$StoreImpl value, $Res Function(_$StoreImpl) then) =
      __$$StoreImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, Genres store});

  @override
  $GenresCopyWith<$Res> get store;
}

/// @nodoc
class __$$StoreImplCopyWithImpl<$Res>
    extends _$StoreCopyWithImpl<$Res, _$StoreImpl>
    implements _$$StoreImplCopyWith<$Res> {
  __$$StoreImplCopyWithImpl(
      _$StoreImpl _value, $Res Function(_$StoreImpl) _then)
      : super(_value, _then);

  /// Create a copy of Store
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? store = null,
  }) {
    return _then(_$StoreImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as Genres,
    ));
  }
}

/// @nodoc

class _$StoreImpl implements _Store {
  const _$StoreImpl({required this.id, required this.store});

  @override
  final int id;
  @override
  final Genres store;

  @override
  String toString() {
    return 'Store(id: $id, store: $store)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoreImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.store, store) || other.store == store));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, store);

  /// Create a copy of Store
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoreImplCopyWith<_$StoreImpl> get copyWith =>
      __$$StoreImplCopyWithImpl<_$StoreImpl>(this, _$identity);
}

abstract class _Store implements Store {
  const factory _Store({required final int id, required final Genres store}) =
      _$StoreImpl;

  @override
  int get id;
  @override
  Genres get store;

  /// Create a copy of Store
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoreImplCopyWith<_$StoreImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
